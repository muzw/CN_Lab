1. RDT 底层是 UDP，为什么程序中可以用`recv`/`send`，而不是`recvfrom`/`sendto`收发数据？

RDT在init_socket_sender()函数初始化发送端socket时,使用了connect()函数绑定了目的端的地址和端口,这样udp就可以使用不需要带目的端的地址和端口的`recv`/`send`收发函数.



2. 停等发送端程序中是如何实现超时重传的？

在发送数据后,使用poll(&pollfd,1,RDT_TIME_OUT)函数在RDT_TIME_OUT时间内等待有数据可读,如果返回值为0,表示没有可读数据,则未接受到ASK,进行超时重传,如果返回值大于0,表示有可读数据,则检查该数据包是否为ASK包并且其序列号是否正确,如果不为ASK包或者序列号不正确,则进行超时重传.





3. 在有发送和接收失败的情况下，怎么保证双方正确地结束通信（参考两军对垒问题）？

接收端收到结束通信的数据包,发送ASK确认包后,并不立即结束通信,而是等待一段时间后关闭,在这段时间里,任然可以对接收到的结束通信的包发送确认包,

防止发送的ASK包丢失,而对端超时重传的包又由于接收端关闭不能响应的情况.

4. 在选择重传协议中为何窗口大小必须小于或等于序列号空间大小的一半？

要保证接收窗口和发送窗口内的序号不能超过序列号空间,所以发送窗口和接收窗口之和小于等于序列号空间,

若发送窗口大于接收窗口,由于接收端只接收接收窗口内的数据包,则发送窗口比接收窗口多余的无意义,

若接收窗口大于发送窗口,显然接收窗口多出来的部分也不能收到数据,也无意义

所以通常窗口大小相等且小于序列号空间大小的一半
